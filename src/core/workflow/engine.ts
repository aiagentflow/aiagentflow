/**
 * Workflow engine — core state machine that orchestrates the agent pipeline.
 *
 * Manages the lifecycle of a development task through stages:
 * Spec → Plan → Code → Review → Test → Fix → QA → Complete
 *
 * Dependency direction: engine.ts → core/errors, agents/types, providers/types, utils
 * Used by: cli/commands/run.ts
 */

import { WorkflowError } from '../errors.js';
import { logger } from '../../utils/logger.js';
import type { AgentRole } from '../../agents/types.js';

// ── Workflow State ──

export const WorkflowState = {
    Idle: 'idle',
    SpecCreated: 'spec_created',
    PlanApproved: 'plan_approved',
    CodeGenerated: 'code_generated',
    ReviewDone: 'review_done',
    ReviewRejected: 'review_rejected',
    TestsWritten: 'tests_written',
    TestsPassed: 'tests_passed',
    TestsFailed: 'tests_failed',
    FixApplied: 'fix_applied',
    QAApproved: 'qa_approved',
    Complete: 'complete',
    Failed: 'failed',
} as const;

export type WorkflowStateValue = (typeof WorkflowState)[keyof typeof WorkflowState];

// ── Workflow Events ──

export type WorkflowEvent =
    | { type: 'SPEC_READY'; payload: { spec: string } }
    | { type: 'PLAN_APPROVED'; payload: { plan: string } }
    | { type: 'CODE_GENERATED'; payload: { files: string[] } }
    | { type: 'REVIEW_DONE'; payload: { approved: boolean; feedback: string } }
    | { type: 'TESTS_WRITTEN'; payload: { testFiles: string[] } }
    | { type: 'TESTS_PASSED' }
    | { type: 'TESTS_FAILED'; payload: { failures: string } }
    | { type: 'FIX_APPLIED'; payload: { files: string[] } }
    | { type: 'QA_APPROVED' }
    | { type: 'QA_REJECTED'; payload: { reason: string } }
    | { type: 'ABORT'; payload?: { reason: string } };

// ── Workflow Context ──

/** All accumulated data during a workflow run. */
export interface WorkflowContext {
    /** The original task description. */
    task: string;
    /** Current state of the workflow. */
    state: WorkflowStateValue;
    /** Number of fix iterations completed. */
    iteration: number;
    /** Maximum allowed fix iterations. */
    maxIterations: number;
    /** Spec generated by the architect agent. */
    spec?: string;
    /** Plan generated by the architect agent. */
    plan?: string;
    /** Files created or modified by the coder agent. */
    generatedFiles: string[];
    /** Review feedback from the reviewer agent. */
    reviewFeedback?: string;
    /** Test files generated by the tester agent. */
    testFiles: string[];
    /** Test failure details. */
    testFailures?: string;
    /** History of all state transitions. */
    history: Array<{ from: WorkflowStateValue; to: WorkflowStateValue; event: string; timestamp: number }>;
}

// ── Valid Transitions ──

/** Defines which state transitions are valid. */
const VALID_TRANSITIONS: Record<WorkflowStateValue, WorkflowStateValue[]> = {
    idle: ['spec_created', 'failed'],
    spec_created: ['plan_approved', 'failed'],
    plan_approved: ['code_generated', 'failed'],
    code_generated: ['review_done', 'review_rejected', 'failed'],
    review_done: ['tests_written', 'failed'],
    review_rejected: ['fix_applied', 'failed'], // fixer runs → fix_applied → code_generated
    tests_written: ['tests_passed', 'tests_failed', 'failed'],
    tests_passed: ['qa_approved', 'failed'],
    tests_failed: ['fix_applied', 'failed'],
    fix_applied: ['code_generated', 'failed'], // loops back to reviewer via code_generated
    qa_approved: ['complete'],
    complete: [],
    failed: [],
};

/** Maps workflow states to which agent runs at that stage. */
export const STATE_AGENT_MAP: Partial<Record<WorkflowStateValue, AgentRole>> = {
    idle: 'architect',
    spec_created: 'architect',
    plan_approved: 'coder',
    code_generated: 'reviewer',
    review_done: 'tester',
    review_rejected: 'fixer',
    tests_failed: 'fixer',
    tests_passed: 'judge',
};

// ── Workflow Engine ──

/**
 * Create a new workflow context for a task.
 */
export function createWorkflowContext(task: string, maxIterations: number = 5): WorkflowContext {
    return {
        task,
        state: WorkflowState.Idle,
        iteration: 0,
        maxIterations,
        generatedFiles: [],
        testFiles: [],
        history: [],
    };
}

/**
 * Transition the workflow to a new state.
 *
 * @throws {WorkflowError} if the transition is invalid or max iterations exceeded.
 */
export function transition(
    context: WorkflowContext,
    event: WorkflowEvent,
): WorkflowContext {
    const currentState = context.state;
    const nextState = resolveNextState(currentState, event);

    // Validate the transition
    const validNextStates = VALID_TRANSITIONS[currentState];
    if (!validNextStates?.includes(nextState)) {
        throw new WorkflowError(
            `Invalid transition: ${currentState} → ${nextState} (event: ${event.type})`,
            { currentState, nextState, event: event.type },
        );
    }

    // Check iteration limit on fix loops
    const isFixLoop = nextState === 'review_rejected' || (nextState === 'fix_applied' && currentState === 'tests_failed');
    const newIteration = isFixLoop ? context.iteration + 1 : context.iteration;

    if (newIteration > context.maxIterations) {
        throw new WorkflowError(
            `Max iterations (${context.maxIterations}) exceeded. Stopping workflow.`,
            { iteration: newIteration, maxIterations: context.maxIterations },
        );
    }

    logger.debug(`Workflow: ${currentState} → ${nextState} (${event.type})`);

    // Build updated context
    const updated: WorkflowContext = {
        ...context,
        state: nextState,
        iteration: newIteration,
        history: [
            ...context.history,
            { from: currentState, to: nextState, event: event.type, timestamp: Date.now() },
        ],
    };

    // Apply event-specific data
    switch (event.type) {
        case 'SPEC_READY':
            updated.spec = event.payload.spec;
            break;
        case 'PLAN_APPROVED':
            updated.plan = event.payload.plan;
            break;
        case 'CODE_GENERATED':
            updated.generatedFiles = [...updated.generatedFiles, ...event.payload.files];
            break;
        case 'REVIEW_DONE':
            updated.reviewFeedback = event.payload.feedback;
            break;
        case 'TESTS_WRITTEN':
            updated.testFiles = [...updated.testFiles, ...event.payload.testFiles];
            break;
        case 'TESTS_FAILED':
            updated.testFailures = event.payload.failures;
            break;
        case 'FIX_APPLIED':
            updated.generatedFiles = [...updated.generatedFiles, ...event.payload.files];
            break;
        default:
            break;
    }

    return updated;
}

/**
 * Check if the workflow is in a terminal state.
 */
export function isTerminal(context: WorkflowContext): boolean {
    return context.state === 'complete' || context.state === 'failed';
}

/**
 * Get the next agent that should run based on current state.
 */
export function getNextAgent(context: WorkflowContext): AgentRole | null {
    return STATE_AGENT_MAP[context.state] ?? null;
}

// ── Private ──

function resolveNextState(current: WorkflowStateValue, event: WorkflowEvent): WorkflowStateValue {
    switch (event.type) {
        case 'SPEC_READY': return WorkflowState.SpecCreated;
        case 'PLAN_APPROVED': return WorkflowState.PlanApproved;
        case 'CODE_GENERATED': return WorkflowState.CodeGenerated;
        case 'REVIEW_DONE':
            return event.payload.approved ? WorkflowState.ReviewDone : WorkflowState.ReviewRejected;
        case 'TESTS_WRITTEN': return WorkflowState.TestsWritten;
        case 'TESTS_PASSED': return WorkflowState.TestsPassed;
        case 'TESTS_FAILED': return WorkflowState.TestsFailed;
        case 'FIX_APPLIED': return WorkflowState.FixApplied;
        case 'QA_APPROVED': return WorkflowState.QAApproved;
        case 'QA_REJECTED': return WorkflowState.CodeGenerated;
        case 'ABORT': return WorkflowState.Failed;
        default: return WorkflowState.Failed;
    }
}
